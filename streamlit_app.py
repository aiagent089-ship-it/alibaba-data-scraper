import streamlit as st
import pandas as pd
import json
from PIL import Image
import os
from script import alibaba_image_search
import time
from datetime import datetime

from negotiation_agent import (
    build_intro_message,
    extract_prices,
    generate_buyer_message,
)


def create_image_name():
    """Create a timestamped filename for uploaded images."""
    timestamp = int(time.time())
    return f"uploaded_image_{timestamp}.png"


st.set_page_config(page_title="Alibaba Suppliers Viewer", layout="wide")
st.title("Alibaba Suppliers Viewer")

st.write(
    "Upload an image (optional). The app will display the uploaded image and show extracted suppliers data from suppliers_data.json."
)

# Image upload flow: persist file in /data for scraper consumption.
uploaded = st.file_uploader("Upload image", type=["png", "jpg", "jpeg"])
if uploaded:
    try:
        img = Image.open(uploaded)
        # Save uploaded image next to this script so existing tools can pick it up
        data_dir = os.path.join(os.path.dirname(__file__), "data")
        os.makedirs(data_dir, exist_ok=True)
        save_path = os.path.join(data_dir, create_image_name())
        img.save(save_path)
        st.success(f"Saved uploaded image to {save_path}")

        # record uploaded path in session state so we don't re-run automatically
        st.session_state["uploaded_path"] = save_path
    except Exception as e:
        st.error(f"Could not open/save image: {e}")

# Provide an explicit control to run the scraper to avoid running on every rerun
if st.session_state.get("uploaded_path"):
    st.markdown("**Uploaded image ready.**")
    if st.button("Run scraper on uploaded image"):
        uploaded_path = st.session_state.get("uploaded_path")
        # avoid re-running for the same image unless user wants to
        if st.session_state.get("scrape_done_for") == uploaded_path:
            st.info("Scraper already run for this uploaded image.")
        else:
            with st.spinner("Running scraper... this may open a browser window"):
                try:
                    alibaba_image_search(uploaded_path)
                    st.session_state["scrape_done_for"] = uploaded_path
                    st.success("Scraper finished â€” suppliers_data.json updated.")
                except Exception as e:
                    st.error(f"Scraper error: {e}")

# Load suppliers data generated by scraper.
data_path = os.path.join(os.path.dirname(__file__), "suppliers_data.json")
if not os.path.exists(data_path):
    st.error(
        "suppliers_data.json not found in repository. Run the scraper or add the file."
    )
else:
    with open(data_path, "r", encoding="utf-8") as f:
        data = json.load(f)

    # Flatten nested supplier entries for easier table/CSV rendering.
    rows = []
    for item in data:
        rows.append(
            {
                "company": item.get("company", ""),
                "location": item.get("location", ""),
                "gold_years": item.get("gold_years", ""),
                "rating": item.get("rating", ""),
                "reviews": item.get("reviews", ""),
                "main_products": ", ".join(item.get("main_products", [])),
                "featured_products": ", ".join(
                    [fp.get("price", "") for fp in item.get("featured_products", [])]
                ),
                "metrics": "; ".join(
                    [f"{k}: {v}" for k, v in item.get("metrics", {}).items()]
                ),
            }
        )

    df = pd.DataFrame(rows)

    st.subheader("Suppliers Table")
    st.dataframe(df)

    # Download as CSV
    csv = df.to_csv(index=False).encode("utf-8")
    st.download_button(
        "Download CSV", data=csv, file_name="suppliers_data.csv", mime="text/csv"
    )

    if st.checkbox("Show raw JSON"):
        st.json(data)

st.divider()
st.subheader("Negotiation Agent")


def _save_negotiation_log(log_path: str, payload: dict) -> None:
    """Append negotiation snapshots to a local JSON log file."""
    try:
        os.makedirs(os.path.dirname(log_path), exist_ok=True)
        if os.path.exists(log_path):
            with open(log_path, "r", encoding="utf-8") as f:
                existing = json.load(f)
        else:
            existing = []
        existing.append(payload)
        with open(log_path, "w", encoding="utf-8") as f:
            json.dump(existing, f, indent=2, ensure_ascii=False)
    except Exception:
        pass


supplier_options = []
if "data" in locals():
    # Populate dropdown with companies from loaded supplier data.
    supplier_options = [item.get("company", "") for item in data if item.get("company")]

col_a, col_b = st.columns(2)
with col_a:
    supplier_name = st.selectbox("Supplier", options=supplier_options or ["(custom)"])
    if supplier_name == "(custom)":
        supplier_name = st.text_input("Custom supplier name", value="")

with col_b:
    product_name = st.text_input("Product name", value="")

quantity = st.number_input(
    "Quantity (units)", min_value=1, step=1, value=500, help="Required for negotiation"
)

col_c, col_d = st.columns(2)
with col_c:
    target_price = st.number_input(
        "Target price per unit (optional)", min_value=0.0, step=0.1, value=0.0
    )
with col_d:
    floor_price = st.number_input(
        "Floor price per unit (optional)", min_value=0.0, step=0.1, value=0.0
    )

target_price_val = target_price if target_price > 0 else None
floor_price_val = floor_price if floor_price > 0 else None

# Session state initialization for negotiation workflow persistence across reruns.
if "negotiation_history" not in st.session_state:
    st.session_state["negotiation_history"] = []
if "negotiation_active" not in st.session_state:
    st.session_state["negotiation_active"] = False
if "lowest_price" not in st.session_state:
    st.session_state["lowest_price"] = None
if "latest_supplier_reply" not in st.session_state:
    st.session_state["latest_supplier_reply"] = ""

start_col, reset_col = st.columns([1, 1])
with start_col:
    # Start negotiation by sending an intro buyer message.
    if st.button("Start negotiation", type="primary"):
        if not product_name or not supplier_name:
            st.error("Please provide supplier and product name before starting.")
        else:
            intro = build_intro_message(product_name, int(quantity))
            st.session_state["negotiation_history"] = [
                {
                    "role": "buyer",
                    "message": intro,
                    "ts": datetime.utcnow().isoformat(),
                }
            ]
            st.session_state["negotiation_active"] = True
            st.session_state["lowest_price"] = None
            st.session_state["latest_supplier_reply"] = ""

with reset_col:
    # Reset all negotiation-related state.
    if st.button("Reset conversation"):
        st.session_state["negotiation_history"] = []
        st.session_state["negotiation_active"] = False
        st.session_state["lowest_price"] = None
        st.session_state["latest_supplier_reply"] = ""

st.markdown("**Conversation**")
# Render conversation history using chat-like bubbles.
for item in st.session_state.get("negotiation_history", []):
    role = item.get("role")
    message = item.get("message", "")
    with st.chat_message("assistant" if role == "buyer" else "user"):
        st.write(message)

supplier_reply = st.text_area(
    "Supplier reply (paste here)",
    value="",
    placeholder="Paste the supplier's reply to continue negotiation...",
)

if st.button("Continue negotiation"):
    if not st.session_state.get("negotiation_active"):
        st.error("Start a negotiation first.")
    elif not supplier_reply.strip():
        st.error("Please enter supplier reply.")
    else:
        # Save supplier reply and track the lowest mentioned price in the thread.
        st.session_state["negotiation_history"].append(
            {
                "role": "supplier",
                "message": supplier_reply.strip(),
                "ts": datetime.utcnow().isoformat(),
            }
        )
        prices = extract_prices(supplier_reply)
        if prices:
            current_min = min(prices)
            lowest = st.session_state.get("lowest_price")
            if lowest is None or current_min < lowest:
                st.session_state["lowest_price"] = current_min

        # Generate next buyer response using negotiation helper.
        response_text, error = generate_buyer_message(
            supplier_name=supplier_name,
            product_name=product_name,
            quantity=int(quantity),
            supplier_reply=supplier_reply.strip(),
            history=st.session_state["negotiation_history"],
            target_price=target_price_val,
            floor_price=floor_price_val,
        )
        st.session_state["negotiation_history"].append(
            {
                "role": "buyer",
                "message": response_text,
                "ts": datetime.utcnow().isoformat(),
            }
        )
        st.session_state["latest_supplier_reply"] = supplier_reply.strip()

        # Persist a log snapshot for later analysis/auditing.
        _save_negotiation_log(
            os.path.join(os.path.dirname(__file__), "data", "negotiations.json"),
            {
                "timestamp": datetime.utcnow().isoformat(),
                "supplier": supplier_name,
                "product": product_name,
                "quantity": int(quantity),
                "target_price": target_price_val,
                "floor_price": floor_price_val,
                "history": st.session_state["negotiation_history"],
                "lowest_price": st.session_state.get("lowest_price"),
            },
        )

st.divider()
st.subheader("Negotiation Dashboard")

# KPI summary for current negotiation session.
status = "Active" if st.session_state.get("negotiation_active") else "Idle"
col_1, col_2, col_3 = st.columns(3)
with col_1:
    st.metric("Status", status)
with col_2:
    st.metric(
        "Lowest mentioned price",
        (
            st.session_state.get("lowest_price")
            if st.session_state.get("lowest_price") is not None
            else "-"
        ),
    )
with col_3:
    st.metric(
        "Latest supplier reply",
        "Received" if st.session_state.get("latest_supplier_reply") else "-",
    )
